<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <title>AI ì˜¤ëª© í›ˆë ¨ - ì „ëµì  ìˆ˜ ì½ê¸°ì™€ ë…¼ë¦¬ë ¥ | SKZ ë‘ë‡Œ í›ˆë ¨ì†Œ</title>
    <meta name="description" content="AIë¥¼ ìƒëŒ€ë¡œ ë‹¹ì‹ ì˜ ë…¼ë¦¬ë ¥ê³¼ ìˆ˜ ì½ê¸° ëŠ¥ë ¥ì„ í…ŒìŠ¤íŠ¸í•˜ì„¸ìš”. 3x3 ê¸ˆìˆ˜ ê·œì¹™ì´ ì ìš©ëœ ì •êµí•œ ì˜¤ëª© ê²Œì„ìœ¼ë¡œ ë‘ë‡Œ ì „ëµì„ í›ˆë ¨í•©ë‹ˆë‹¤.">
    <meta property="og:title" content="SKZ AI ì˜¤ëª©: ë‹¹ì‹ ì˜ ì „ëµì€ AIë¥¼ ì´ê¸¸ ìˆ˜ ìˆë‚˜ìš”?">
    <meta property="og:description" content="ë…¼ë¦¬ì  ì‚¬ê³ ì™€ ê³µê°„ ì§€ê°ë ¥ì„ í‚¤ìš°ëŠ” ì˜¤ëª© í›ˆë ¨.">
    
    <link rel="canonical" href="https://www.skztools.com/game7.html">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3698246671823168" crossorigin="anonymous"></script>

    <style>
        /* --- [1] ê³µí†µ ë ˆì´ì•„ì›ƒ (ë””ìì¸ í†µì¼ì„±) --- */
        :root { 
            --primary-color: #1a3a5f; 
            --bg-color: #f4f7f9; 
            --logic-color: #b91c1c; 
            --board-color: #eecf9b;
        }
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body { font-family: 'Pretendard', sans-serif; background-color: var(--bg-color); margin: 0; color: #333; line-height: 1.6; }
        
        header { background: var(--primary-color); color: white; padding: 1.2rem; text-align: center; }
        header h1 { margin: 0; font-size: 1.4rem; font-weight: 800; }
        header h1 a { text-decoration: none; color: inherit; }

        nav.main-nav { background: white; display: flex; justify-content: center; box-shadow: 0 2px 5px rgba(0,0,0,0.05); position: sticky; top: 0; z-index: 1000; }
        nav.main-nav a { text-decoration: none; color: #666; font-weight: bold; font-size: 0.9rem; padding: 1rem; }
        nav.main-nav a.active { color: var(--primary-color) !important; border-bottom: 2px solid var(--primary-color); }

        .category-tabs { display: flex; background: #fff; border-bottom: 1px solid #eee; justify-content: center; }
        .category-tabs a { flex: 1; text-align: center; padding: 15px 10px; text-decoration: none; color: #bbb; font-size: 0.9rem; font-weight: bold; max-width: 200px; }
        .category-tabs a.active { color: var(--logic-color) !important; border-bottom: 3px solid var(--logic-color); }

        .game-sub-nav { display: flex; gap: 10px; padding: 15px; justify-content: center; background: #f8f9fa; overflow-x: auto; white-space: nowrap; border-bottom: 1px solid #eee; }
        .game-sub-nav a { padding: 6px 14px; background: white; border: 1px solid #eee; border-radius: 20px; font-size: 0.75rem; text-decoration: none; color: #666; }
        .game-sub-nav a.active { background: #333 !important; color: white !important; }

        /* --- [2] ê²Œì„ ì „ìš© ë””ìì¸ --- */
        .container { width: 95%; max-width: 500px; margin: 1.5rem auto; padding: 20px; background: white; border-radius: 28px; box-shadow: 0 10px 30px rgba(0,0,0,0.05); text-align: center; }
        .game-guide { background: #f0f7ff; border-radius: 15px; padding: 15px; font-size: 0.85rem; color: #444; margin-bottom: 15px; text-align: left; border-left: 4px solid var(--logic-color); }

        .status-box { background: #f8fafc; padding: 12px; border-radius: 12px; margin-bottom: 15px; display: flex; justify-content: space-between; align-items: center; font-weight: bold; font-size: 0.9rem; border: 1px solid #e2e8f0; }

        #canvas-wrapper { 
            width: 100%; aspect-ratio: 1 / 1; background: var(--board-color); 
            border-radius: 12px; position: relative; touch-action: none; 
            box-shadow: inset 0 0 20px rgba(0,0,0,0.1); margin-bottom: 10px;
            border: 5px solid #d4b483;
        }
        canvas { width: 100%; height: 100%; display: block; border-radius: 8px; cursor: crosshair; }
        
        #msg-area { color: var(--logic-color); font-size: 0.85rem; height: 1.5rem; margin: 5px 0; font-weight: bold; }

        .controls { display: flex; gap: 10px; justify-content: center; margin-top: 15px; }
        .btn { border: none; padding: 14px 20px; border-radius: 50px; font-weight: bold; cursor: pointer; transition: 0.2s; flex: 1; font-size: 0.9rem; }
        .btn-reset { background: var(--primary-color); color: white; }
        .btn-undo { background: #e2e8f0; color: #444; }
        .btn:active { transform: scale(0.98); opacity: 0.9; }

        .mode-selector { display: flex; justify-content: center; gap: 8px; margin-bottom: 15px; }
        .mode-btn { cursor: pointer; color: #888; font-size: 0.75rem; padding: 8px 18px; border: 1px solid #ddd; border-radius: 20px; background: white; transition: 0.2s; }
        .mode-btn.active { color: var(--logic-color); border-color: var(--logic-color); font-weight: bold; background: #fff5f5; }

        footer { text-align: center; padding: 3rem 0; color: #bbb; font-size: 0.75rem; background: #fff; border-top: 1px solid #eee; margin-top: 40px; }
    </style>
</head>
<body>

<header><h1><a href="/">SKZ ë‘ë‡Œ í›ˆë ¨ì†Œ</a></h1></header>

<nav class="main-nav">
    <a href="/">ë¸Œë ˆì¸ ë¶„ì„ì‹¤</a>
    <a href="dash.html" class="active">ë‘ë‡Œ í›ˆë ¨ì„¼í„°</a>
    <a href="report.html">ë‚˜ì˜ ë‘ë‡Œì ìˆ˜</a>
</nav>

<nav class="category-tabs">
    <a href="game.html">ì •ë°€ ì§‘ì¤‘</a>
    <a href="game2.html" class="active">ì „ëµ ë…¼ë¦¬</a>
    <a href="game3.html">ì¾Œì† íŒë‹¨</a>
</nav>

<nav class="game-sub-nav">
    <a href="game2.html">ğŸ§© ë¯¸ë‹ˆ ìŠ¤ë„ì¿ </a>
    <a href="game7.html" class="active">âš« AI ì˜¤ëª©</a>
</nav>

<main class="container">
    <div class="game-guide">
        <strong>ğŸ§  ì˜¤ëª© ìˆ˜ ì½ê¸° (ì „ëµ ìˆ˜ë¦½)</strong><br>
        AIë¥¼ ìƒëŒ€ë¡œ 5ëª©ì„ ë¨¼ì € ì™„ì„±í•˜ì„¸ìš”. <strong>í‘ëŒ(ì‚¬ìš©ì)ì€ 3x3 ê¸ˆìˆ˜</strong>ê°€ ì ìš©ë©ë‹ˆë‹¤. í•œ ìˆ˜ ì•ì„ ë‚´ë‹¤ë³´ëŠ” ëŠ¥ë ¥ì„ ê¸°ë¥´ì„¸ìš”.
    </div>

    <section class="mode-selector">
        <button id="btn-ai" class="mode-btn active" onclick="changeMode('ai')">AI ëŒ€ê²° (í›ˆë ¨)</button>
        <button id="btn-p2p" class="mode-btn" onclick="changeMode('p2p')">2ì¸ ëŒ€ê²°</button>
    </section>

    <div class="status-box">
        <span id="turnDisplay">ì°¨ë¡€: í‘ëŒ â—</span>
        <span id="gameModeText" style="font-size: 0.75rem; color: #64748b;">AI í›ˆë ¨ ëª¨ë“œ</span>
    </div>

    <div id="canvas-wrapper"><canvas id="omokCanvas"></canvas></div>
    <div id="msg-area"></div>

    <div class="controls">
        <button class="btn btn-undo" onclick="undo()">í•œ ìˆ˜ ë¬´ë¥´ê¸°</button>
        <button class="btn btn-reset" onclick="resetGame()">ìƒˆ ê²Œì„</button>
    </div>
</main>

<footer>
    <div style="margin-bottom: 10px;">
        &copy; 2026 SKZ Brain Lab. All rights reserved.
    </div>
</footer>



<script>
    const canvas = document.getElementById('omokCanvas');
    const ctx = canvas.getContext('2d');
    const turnDisplay = document.getElementById('turnDisplay');
    const msgArea = document.getElementById('msg-area');
    
    const boardSize = 15;
    let cellSize;
    let board = Array.from(Array(boardSize), () => Array(boardSize).fill(0));
    let moveHistory = [];
    let gameOver = false;
    let currentMode = 'ai'; 
    let currentPlayer = 1;

    function initCanvas() {
        const dpr = window.devicePixelRatio || 1;
        const containerWidth = canvas.parentElement.clientWidth - 10; // í…Œë‘ë¦¬ ì œì™¸
        canvas.width = containerWidth * dpr;
        canvas.height = containerWidth * dpr;
        ctx.scale(dpr, dpr);
        cellSize = containerWidth / boardSize;
        drawBoard();
    }

    function drawBoard() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // ê²©ìì„  ê·¸ë¦¬ê¸°
        ctx.strokeStyle = "rgba(85, 58, 42, 0.4)";
        ctx.lineWidth = 1;
        
        for (let i = 0; i < boardSize; i++) {
            const pos = cellSize/2 + i*cellSize;
            // ê°€ë¡œ
            ctx.beginPath();
            ctx.moveTo(cellSize/2, pos);
            ctx.lineTo(cellSize*boardSize - cellSize/2, pos);
            ctx.stroke();
            // ì„¸ë¡œ
            ctx.beginPath();
            ctx.moveTo(pos, cellSize/2);
            ctx.lineTo(pos, cellSize*boardSize - cellSize/2);
            ctx.stroke();
        }

        // í™”ì  (ì˜¤ëª©íŒì˜ ì )
        const stars = [3, 7, 11];
        stars.forEach(y => stars.forEach(x => {
            ctx.beginPath();
            ctx.arc(cellSize/2 + x*cellSize, cellSize/2 + y*cellSize, 3, 0, Math.PI*2);
            ctx.fillStyle = "#553a2a";
            ctx.fill();
        }));

        // ëŒ ê·¸ë¦¬ê¸°
        board.forEach((row, y) => row.forEach((val, x) => {
            if(val !== 0) drawStone(x, y, val);
        }));
    }

    function drawStone(x, y, player) {
        const px = cellSize/2 + x*cellSize;
        const py = cellSize/2 + y*cellSize;
        
        ctx.shadowBlur = 5;
        ctx.shadowColor = "rgba(0,0,0,0.4)";
        ctx.beginPath();
        ctx.arc(px, py, cellSize/2 - 3, 0, Math.PI * 2);
        
        if(player === 1) { // í‘ëŒ
            const grad = ctx.createRadialGradient(px-3, py-3, 1, px, py, cellSize/2);
            grad.addColorStop(0, "#666");
            grad.addColorStop(1, "#000");
            ctx.fillStyle = grad;
        } else { // ë°±ëŒ
            const grad = ctx.createRadialGradient(px-3, py-3, 1, px, py, cellSize/2);
            grad.addColorStop(0, "#fff");
            grad.addColorStop(1, "#d1d5db");
            ctx.fillStyle = grad;
        }
        ctx.fill();
        ctx.shadowBlur = 0;

        // ë§ˆì§€ë§‰ ìˆ˜ í•˜ì´ë¼ì´íŠ¸ í‘œì‹œ
        if (moveHistory.length > 0) {
            const last = moveHistory[moveHistory.length - 1];
            if (last.x === x && last.y === y) {
                ctx.strokeStyle = player === 1 ? "#ef4444" : "#ef4444";
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }
    }

    function changeMode(mode) {
        currentMode = mode;
        document.getElementById('btn-ai').classList.toggle('active', mode === 'ai');
        document.getElementById('btn-p2p').classList.toggle('active', mode === 'p2p');
        document.getElementById('gameModeText').innerText = mode === 'ai' ? "AI í›ˆë ¨ ëª¨ë“œ" : "2ì¸ ëŒ€ê²° ëª¨ë“œ";
        resetGame();
    }

    function resetGame() {
        board = Array.from(Array(boardSize), () => Array(boardSize).fill(0));
        moveHistory = [];
        gameOver = false;
        currentPlayer = 1;
        turnDisplay.innerText = "ì°¨ë¡€: í‘ëŒ â—";
        msgArea.innerText = "";
        drawBoard();
    }

    canvas.addEventListener('pointerdown', (e) => {
        if(gameOver || (currentMode === 'ai' && currentPlayer === 2)) return;
        const rect = canvas.getBoundingClientRect();
        const x = Math.round((e.clientX - rect.left - cellSize/2) / cellSize);
        const y = Math.round((e.clientY - rect.top - cellSize/2) / cellSize);
        
        if (x >= 0 && x < boardSize && y >= 0 && y < boardSize && board[y][x] === 0) {
            if (currentPlayer === 1 && isDoubleThree(x, y, 1)) {
                msgArea.innerText = "âš ï¸ í‘ëŒì€ 3x3 ìë¦¬ì— ë‘˜ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!";
                return;
            }
            makeMove(x, y);
        }
    });

    function makeMove(x, y) {
        board[y][x] = currentPlayer;
        moveHistory.push({x, y, p: currentPlayer});
        msgArea.innerText = "";
        drawBoard();

        if (checkWin(x, y, currentPlayer)) {
            gameOver = true;
            const winner = currentPlayer === 1 ? "í‘ëŒ" : "ë°±ëŒ";
            turnDisplay.innerText = winner + " ìŠ¹ë¦¬! ğŸ‰";
            if (currentMode === 'ai') saveGameResult(currentPlayer === 1);
            return;
        }

        currentPlayer = currentPlayer === 1 ? 2 : 1;
        turnDisplay.innerText = `ì°¨ë¡€: ${currentPlayer === 1 ? "í‘ëŒ â—" : "ë°±ëŒ â—‹"}`;
        
        if (currentMode === 'ai' && currentPlayer === 2) {
            setTimeout(aiMove, 600);
        }
    }

    function saveGameResult(isUserWin) {
        let logicScore = 0;
        const moves = moveHistory.length;
        if (isUserWin) {
            // ë¹¨ë¦¬ ì´ê¸¸ìˆ˜ë¡ ë†’ì€ ì ìˆ˜
            logicScore = Math.min(100, 95 + Math.floor((60 - moves) / 2));
        } else {
            // ì˜¤ë˜ ë²„í‹¸ìˆ˜ë¡ ë†’ì€ ì ìˆ˜
            logicScore = Math.min(80, Math.floor(moves * 1.8));
        }

        localStorage.setItem('logicScore', logicScore); // ì „ëµ ë…¼ë¦¬ ì¹´í…Œê³ ë¦¬ í†µí•©
        
        setTimeout(() => {
            const msg = isUserWin ? "ìŠ¹ë¦¬! ì™„ë²½í•œ ìˆ˜ ì½ê¸°ì˜€ìŠµë‹ˆë‹¤." : "íŒ¨ë°°.. AIê°€ ë‹¹ì‹ ì˜ ìˆ˜ë¥¼ ì½ì—ˆìŠµë‹ˆë‹¤.";
            if (confirm(`${msg}\në‚˜ì˜ ì „ëµ ì ìˆ˜: ${logicScore}ì \n\në‘ë‡Œ ë¦¬í¬íŠ¸ë¥¼ í™•ì¸í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) {
                location.href = 'report.html';
            }
        }, 500);
    }

    // AI ì•Œê³ ë¦¬ì¦˜ (ê°€ì¤‘ì¹˜ ê¸°ë°˜ íƒìƒ‰)
    function aiMove() {
        if(gameOver) return;
        let bestScore = -1, bestMoves = [];

        for(let y=0; y<boardSize; y++) {
            for(let x=0; x<boardSize; x++) {
                if(board[y][x] === 0) {
                    let score = evaluateMove(x, y);
                    if(score > bestScore) {
                        bestScore = score;
                        bestMoves = [{x, y}];
                    } else if(score === bestScore) {
                        bestMoves.push({x, y});
                    }
                }
            }
        }
        const finalMove = bestMoves[Math.floor(Math.random() * bestMoves.length)];
        makeMove(finalMove.x, finalMove.y);
    }

    function evaluateMove(x, y) {
        let total = 0;
        const directions = [[1,0], [0,1], [1,1], [1,-1]];
        directions.forEach(([dx, dy]) => {
            total += getLineScore(x, y, dx, dy, 2); // AI ê³µê²©ì„±
            total += getLineScore(x, y, dx, dy, 1) * 1.2; // ë°©ì–´ ìš°ì„ ìˆœìœ„
        });
        return total;
    }

    function getLineScore(x, y, dx, dy, p) {
        let count = 1, open = 0;
        [[dx, dy], [-dx, -dy]].forEach(([sx, sy]) => {
            for (let i = 1; i < 5; i++) {
                let nx = x + sx*i, ny = y + sy*i;
                if (nx>=0 && nx<boardSize && ny>=0 && ny<boardSize) {
                    if (board[ny][nx] === p) count++;
                    else if (board[ny][nx] === 0) { open++; break; }
                    else break;
                } else break;
            }
        });
        if(count >= 5) return 100000;
        if(count === 4 && open === 2) return 10000;
        if(count === 4 && open === 1) return 2500;
        if(count === 3 && open === 2) return 1800;
        return count * 15;
    }

    function checkWin(x, y, p) {
        const directions = [[1,0], [0,1], [1,1], [1,-1]];
        for (let [dx, dy] of directions) {
            let count = 1;
            [[dx, dy], [-dx, -dy]].forEach(([sx, sy]) => {
                for (let i = 1; i < 5; i++) {
                    let nx = x + sx*i, ny = y + sy*i;
                    if (nx>=0 && nx<boardSize && ny>=0 && ny<boardSize && board[ny][nx] === p) count++;
                    else break;
                }
            });
            if (count >= 5) return true;
        }
        return false;
    }

    function undo() {
        if (gameOver || moveHistory.length === 0) return;
        const steps = (currentMode === 'ai') ? 2 : 1;
        for(let i=0; i<steps; i++) {
            if(moveHistory.length > 0) {
                const m = moveHistory.pop();
                board[m.y][m.x] = 0;
            }
        }
        if(currentMode !== 'ai') currentPlayer = currentPlayer === 1 ? 2 : 1;
        turnDisplay.innerText = `ì°¨ë¡€: ${currentPlayer === 1 ? "í‘ëŒ â—" : "ë°±ëŒ â—‹"}`;
        drawBoard();
    }

    // 3x3 ê¸ˆìˆ˜ ë¡œì§
    function isDoubleThree(x, y, p) {
        let open3 = 0;
        board[y][x] = p;
        [[1,0], [0,1], [1,1], [1,-1]].forEach(([dx, dy]) => {
            let count = 1, openEnds = 0;
            [[dx, dy], [-dx, -dy]].forEach(([sx, sy]) => {
                let nx1 = x + sx, ny1 = y + sy;
                if (nx1>=0 && nx1<boardSize && ny1>=0 && ny1<boardSize && board[ny1][nx1] === p) {
                    count++;
                    let nx2 = x + sx*2, ny2 = y + sy*2;
                    if (nx2>=0 && nx2<boardSize && ny2>=0 && ny2<boardSize && board[ny2][nx2] === 0) openEnds++;
                } else if (nx1>=0 && nx1<boardSize && ny1>=0 && ny1<boardSize && board[ny1][nx1] === 0) {
                    openEnds++;
                }
            });
            if(count === 3 && openEnds === 2) open3++;
        });
        board[y][x] = 0;
        return open3 >= 2;
    }

    window.addEventListener('resize', initCanvas);
    initCanvas();
</script>
</body>
</html>
