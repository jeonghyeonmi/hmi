<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AI 오목 훈련 | SKZ Brain Lab</title>
    <style>
        :root { 
            --primary-color: #1a3a5f; --bg-color: #f4f7f9; --accent-color: #d35400; 
            --text-main: #2c3e50; --white: #ffffff; --board-color: #edc9af;
        }
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body { font-family: 'Pretendard', sans-serif; background-color: var(--bg-color); margin: 0; overflow-x: hidden; }
        
        header { background: var(--primary-color); color: white; padding: 1.2rem; text-align: center; }
        header h1 { margin: 0; font-size: 1.4rem; font-weight: 800; }
        header h1 a { text-decoration: none; color: inherit; }
        nav.main-nav { 
            background: white; padding: 0.8rem; display: flex; justify-content: center; gap: 1.2rem; 
            box-shadow: 0 2px 5px rgba(0,0,0,0.05); position: sticky; top: 0; z-index: 1000;
        }
        nav.main-nav a { text-decoration: none; color: var(--primary-color); font-weight: bold; font-size: 0.9rem; }
        nav.main-nav a.active { color: var(--accent-color); border-bottom: 2px solid var(--accent-color); }

        .game-container { width: 94%; max-width: 500px; margin: 1.5rem auto; text-align: center; }
        .status-bar { 
            background: var(--white); padding: 15px; border-radius: 15px; margin-bottom: 15px;
            display: flex; justify-content: space-between; align-items: center; font-weight: bold;
            box-shadow: 0 4px 10px rgba(0,0,0,0.05);
        }

        #canvas-wrapper { 
            width: 100%; aspect-ratio: 1 / 1; background: var(--board-color); 
            border-radius: 10px; box-shadow: 0 8px 20px rgba(0,0,0,0.1);
            position: relative; touch-action: none;
        }
        canvas { width: 100%; height: 100%; display: block; }

        .controls { display: flex; gap: 10px; justify-content: center; margin-top: 20px; }
        .btn {
            border: none; padding: 12px 25px; border-radius: 50px; font-weight: bold; cursor: pointer; transition: 0.2s;
        }
        .btn-reset { background: var(--primary-color); color: white; }
        .btn-undo { background: #e2e8f0; color: var(--text-main); }
        .btn:active { transform: scale(0.95); }

        #msg { color: #e74c3c; font-size: 0.8rem; position: absolute; bottom: -25px; width: 100%; left: 0; }
        footer { text-align: center; padding: 3rem 0; color: #bbb; font-size: 0.8rem; }
    </style>
</head>
<body>

<header><h1><a href="index.html">SKZ 두뇌 훈련소</a></h1></header>
<nav class="main-nav">
    <a href="index.html">홈</a>
    <a href="game.html">집중력</a>
    <a href="game2.html">논리력</a>
    <a href="game3.html">판단력</a>
    <a href="report.html">리포트</a>
    <a href="posts.html">분석실</a>
</nav>

<main class="game-container">
    <div class="status-bar">
        <span id="turnDisplay">당신의 차례 (흑돌)</span>
        <button onclick="undo()" style="font-size: 0.8rem; background: #f8fafc; border: 1px solid #cbd5e1; padding: 5px 12px; border-radius: 8px; cursor: pointer;">무르기</button>
    </div>

    <div id="canvas-wrapper">
        <canvas id="omokCanvas"></canvas>
        <div id="msg"></div>
    </div>

    <div class="controls">
        <button class="btn btn-reset" onclick="location.reload()">새 게임</button>
    </div>
</main>

<footer><p>&copy; 2026 SKZ Brain Lab. All rights reserved.</p></footer>

<script>
    const canvas = document.getElementById('omokCanvas');
    const ctx = canvas.getContext('2d');
    const turnDisplay = document.getElementById('turnDisplay');
    const msgArea = document.getElementById('msg');
    
    const boardSize = 15;
    let cellSize;
    let board = Array.from(Array(boardSize), () => Array(boardSize).fill(0));
    let moveHistory = []; // 무르기를 위한 수 기록 저장소
    let gameOver = false;

    function initCanvas() {
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = rect.width * dpr;
        ctx.scale(dpr, dpr);
        cellSize = rect.width / boardSize;
        drawBoard();
    }

    function drawBoard() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.strokeStyle = "#333";
        ctx.lineWidth = 1;
        for (let i = 0; i < boardSize; i++) {
            ctx.beginPath();
            ctx.moveTo(cellSize/2, cellSize/2 + i*cellSize);
            ctx.lineTo(canvas.width/devicePixelRatio - cellSize/2, cellSize/2 + i*cellSize);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(cellSize/2 + i*cellSize, cellSize/2);
            ctx.lineTo(cellSize/2 + i*cellSize, canvas.width/devicePixelRatio - cellSize/2);
            ctx.stroke();
        }
        for(let y=0; y<boardSize; y++) {
            for(let x=0; x<boardSize; x++) {
                if(board[y][x] !== 0) drawStone(x, y, board[y][x]);
            }
        }
    }

    function drawStone(x, y, player) {
        ctx.beginPath();
        ctx.arc(cellSize/2 + x*cellSize, cellSize/2 + y*cellSize, cellSize/2 - 4, 0, Math.PI * 2);
        ctx.fillStyle = player === 1 ? "#000" : "#fff";
        ctx.fill();
        if(player === 2) {
            ctx.strokeStyle = "#ccc";
            ctx.stroke();
        }
        // 마지막 수 표시 (힌트)
        if (moveHistory.length > 0) {
            const last = moveHistory[moveHistory.length - 1];
            if (last.x === x && last.y === y) {
                ctx.beginPath();
                ctx.arc(cellSize/2 + x*cellSize, cellSize/2 + y*cellSize, 3, 0, Math.PI * 2);
                ctx.fillStyle = player === 1 ? "#fff" : "#000";
                ctx.fill();
            }
        }
    }

    // 무르기 기능 구현
    function undo() {
        if (gameOver || moveHistory.length < 2 || turnDisplay.innerText.includes("AI")) return;
        
        // AI의 마지막 수와 사용자의 마지막 수를 배열에서 제거
        const aiLastMove = moveHistory.pop();
        const userLastMove = moveHistory.pop();
        
        board[aiLastMove.y][aiLastMove.x] = 0;
        board[userLastMove.y][userLastMove.x] = 0;
        
        drawBoard();
        turnDisplay.innerText = "당신의 차례 (흑돌)";
        msgArea.innerText = "무르기가 완료되었습니다.";
        setTimeout(() => { msgArea.innerText = ""; }, 1500);
    }

    function isDoubleThree(x, y, player) {
        if (player !== 1) return false;
        let openThrees = 0;
        const directions = [[1,0], [0,1], [1,1], [1,-1]];
        board[y][x] = player;
        for (let [dx, dy] of directions) {
            if (isOpenThree(x, y, dx, dy, player)) openThrees++;
        }
        board[y][x] = 0;
        return openThrees >= 2;
    }

    function isOpenThree(x, y, dx, dy, player) {
        let count = 1; let openEnds = 0;
        [[dx, dy], [-dx, -dy]].forEach(([sx, sy]) => {
            let spaceFound = false;
            for (let i = 1; i <= 4; i++) {
                let nx = x + sx * i, ny = y + sy * i;
                if (nx < 0 || nx >= boardSize || ny < 0 || ny >= boardSize) break;
                if (board[ny][nx] === player) { if (!spaceFound) count++; else break; }
                else if (board[ny][nx] === 0) { openEnds++; spaceFound = true; break; }
                else break;
            }
        });
        return count === 3 && openEnds === 2;
    }

    function checkWin(x, y, player) {
        const directions = [[1,0], [0,1], [1,1], [1,-1]];
        for (let [dx, dy] of directions) {
            let count = 1;
            [[dx, dy], [-dx, -dy]].forEach(([sx, sy]) => {
                for (let i = 1; i < 5; i++) {
                    let nx = x + sx*i, ny = y + sy*i;
                    if (nx >= 0 && nx < boardSize && ny >= 0 && ny < boardSize && board[ny][nx] === player) count++;
                    else break;
                }
            });
            if (count >= 5) return true;
        }
        return false;
    }

    function aiMove() {
        if(gameOver) return;
        let bestScore = -1;
        let move = {x: 7, y: 7};
        for(let y=0; y<boardSize; y++) {
            for(let x=0; x<boardSize; x++) {
                if(board[y][x] === 0) {
                    let score = evaluateMove(x, y);
                    if(score > bestScore) { bestScore = score; move = {x, y}; }
                }
            }
        }
        board[move.y][move.x] = 2;
        moveHistory.push({x: move.x, y: move.y, player: 2}); // AI 기록 저장
        drawBoard();
        if(checkWin(move.x, move.y, 2)) {
            gameOver = true;
            turnDisplay.innerText = "AI 승리!";
            setTimeout(() => alert("AI가 승리했습니다!"), 100);
        } else {
            turnDisplay.innerText = "당신의 차례 (흑돌)";
        }
    }

    function evaluateMove(x, y) {
        let totalScore = 0;
        const directions = [[1,0], [0,1], [1,1], [1,-1]];
        for(let [dx, dy] of directions) {
            totalScore += getLineScore(x, y, dx, dy, 2);
            totalScore += getLineScore(x, y, dx, dy, 1) * 1.1;
        }
        return totalScore;
    }

    function getLineScore(x, y, dx, dy, player) {
        let count = 0; let block = 0;
        [[dx, dy], [-dx, -dy]].forEach(([sx, sy]) => {
            for (let i = 1; i < 5; i++) {
                let nx = x + sx*i, ny = y + sy*i;
                if (nx >= 0 && nx < boardSize && ny >= 0 && ny < boardSize) {
                    if (board[ny][nx] === player) count++;
                    else if (board[ny][nx] !== 0) { block++; break; }
                    else break;
                } else { block++; break; }
            }
        });
        if(count >= 4) return 10000;
        if(count === 3) return block === 0 ? 5000 : 500;
        return count * 10;
    }

    canvas.addEventListener('pointerdown', (e) => {
        if(gameOver || turnDisplay.innerText.includes("AI")) return;
        const rect = canvas.getBoundingClientRect();
        const x = Math.round((e.clientX - rect.left - cellSize/2) / cellSize);
        const y = Math.round((e.clientY - rect.top - cellSize/2) / cellSize);

        if (x >= 0 && x < boardSize && y >= 0 && y < boardSize && board[y][x] === 0) {
            if (isDoubleThree(x, y, 1)) {
                msgArea.innerText = "3x3 금수 위치입니다!";
                setTimeout(() => { msgArea.innerText = ""; }, 2000);
                return;
            }
            board[y][x] = 1;
            moveHistory.push({x, y, player: 1}); // 사용자 기록 저장
            drawBoard();
            if (checkWin(x, y, 1)) {
                gameOver = true;
                turnDisplay.innerText = "당신의 승리!";
                setTimeout(() => alert("승리하셨습니다!"), 100);
            } else {
                turnDisplay.innerText = "AI가 생각 중...";
                setTimeout(aiMove, 600);
            }
        }
    });

    window.addEventListener('resize', initCanvas);
    initCanvas();
</script>
</body>
</html>
